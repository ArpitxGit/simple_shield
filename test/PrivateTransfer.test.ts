import { ethers } from "hardhat";
const { provider } = ethers;
import { SignerWithAddress } from "@nomiclabs/hardhat-ethers/signers";
import { Contract, ContractFactory, utils } from "ethers";
import { expect } from "chai";
import { readFileSync } from 'fs';
import path from 'path';
import toml from 'toml';
import { Pedersen, PooledPedersen, SinglePedersen } from '@aztec/barretenberg/crypto/pedersen';
import { BarretenbergWasm, WorkerPool } from '@aztec/barretenberg/wasm';
import { toBufferBE } from 'bigint-buffer';
import { compile } from '@noir-lang/noir_wasm';
import { setup_generic_prover_and_verifier, create_proof, verify_proof } from '@noir-lang/barretenberg/dest/client_proofs';
// import { compile } from '@noir-lang/noir-js';

// @ts-ignore
// import { plonk } from "snarkjs";
// @ts-ignore
// import { babyJub, pedersenHash, circomlib } from "circomlibjs";
import { MerkleTree } from "../utils/MerkleTree";
// @ts-ignore
// const { babyJub, pedersenHash } = require("circomlib");

const amount = process.env.ETH_AMOUNT || "1000000000000000000"; // 1 ether

// contract
let [Verifier, PrivateTransfer]: ContractFactory[] = [];
let [verifier, privateTransfer]: Contract[] = [];
let signers: SignerWithAddress[];
let commitments: string[] = [];
let root = "";
let barretenberg: BarretenbergWasm;

before(async () => {
  PrivateTransfer = await ethers.getContractFactory("PrivateTransfer");
  Verifier = await ethers.getContractFactory("TurboVerifier");
  signers = await ethers.getSigners();
  barretenberg = await BarretenbergWasm.new();

  let pedersen = new SinglePedersen(barretenberg);

  // TODO: move this to its own MerkleTree test
  const tree = new MerkleTree(3, barretenberg);
  tree.insert("2ab135000c911caaf6fcc25eeeace4ea8be41f3531b2596c0c1a7ac22eb11b57");
  let merkleProof = tree.proof(0);
  console.dir(merkleProof.pathElements);
  console.log('root: ', tree.root());
  let b = Buffer.from("2ab135000c911caaf6fcc25eeeace4ea8be41f3531b2596c0c1a7ac22eb11b57", "hex");
  let c = Buffer.from("1cdcf02431ba623767fe389337d011df1048dcc24b98ed81cec97627bab454a0", "hex");
  let e00 = pedersen.compress(b, c);
  console.log('e00: ', e00.toString('hex'));
  let d = Buffer.from("0833de91a69b13953edec6be92977bad49f0dbac520ec8f63d723f7692a446b8", "hex");
  let e01 = pedersen.compress(e00, d);
  console.log('e01: ', e01.toString('hex'));
  let e = Buffer.from("0bf4c916dd193a7ac4748d91063d7244214d70cb2e338eb2cfff1fa4b5f1633d", "hex");
  let e02 = pedersen.compress(e01, e);
  console.log('e01: ', e02.toString('hex'));

  let x = Buffer.from("0000000000000000000000000000000000000000000000000000000000000001", "hex");
  let y = Buffer.from("0000000000000000000000000000000000000000000000000000000000000001", "hex");

  console.log('y: ', y);
  let hashRes = pedersen.compressInputs([x]);

  let hashRes2 = pedersen.compress(x, y);
  console.log('pedersen res: ', hashRes.toString('hex'));
  console.log('pedersen res bytes: ', hashRes);
  console.log('pedersen res 2: ', hashRes2.toString('hex'));
  console.log('pedersen res 2 bytes: ', hashRes2);
});

beforeEach(async function () {
  root = "0x1221a375f6b4305e493497805102054f2847790244f92d09f6e859c083be2627";
  let commitment = "0x2ab135000c911caaf6fcc25eeeace4ea8be41f3531b2596c0c1a7ac22eb11b57";
  commitments.push(commitment);
  verifier = await Verifier.deploy();
  privateTransfer = await PrivateTransfer.deploy(verifier.address, amount, root, commitments, { value: utils.parseEther("1.0") } );
});
  
describe("mixer withdraw", () => {
  it("should work", async () => {
    const privateTransactionAmount = utils.parseEther("1.0");
    
    let proverToml = await readFileSync(path.resolve(__dirname,`../circuits/Prover.toml`));
    var proverInputs = toml.parse(proverToml.toString());
    console.log('proof location ' + path.resolve(__dirname,`../circuits/proofs/p.proof`));
    // NOTE: this reads from the proof generated by nargo prove, and buffer doesn't give accurate binary data on its own needs to be converted
    // proof is not pre-pended with public inputs, unlike in Noir/barretenberg don't need to prepend for generated Sol verifier
    let proofBuffer = await readFileSync(path.resolve(__dirname,`../circuits/proofs/p.proof`));
    console.log('proofBuffer: ', proofBuffer);

    let proofBytes = hexToBytes(proofBuffer.toString());
    // console.log('proofBuffer: ', proofBuffer.toString());

    // generate withdraw input (nullifier, commitment, etc)
    let commitment = "0x2ab135000c911caaf6fcc25eeeace4ea8be41f3531b2596c0c1a7ac22eb11b57";
    let nullifierHash = proverInputs.return[0];
    let receiver_note_commitment = proverInputs.return[1];
    let root = proverInputs.note_root;
    let recipient = signers[1].address;

    let mergedRawPubInputs = hexListToBytes([root, nullifierHash, receiver_note_commitment]);

    let pubInputsByteArray = [...mergedRawPubInputs];

    let args = [[...proofBytes], pubInputsByteArray, root, commitment, nullifierHash, recipient];

    // verify proof and perform withdraw
    // NOTE: curently being done by nargo and fetched from circuits folder rather than running wasm file
    const before = await provider.getBalance(recipient);
    await privateTransfer.withdraw(...args);
    // Simply calling verify method for the TurboVerifier
    // await callTurboVerifier([...proofBytes], pubInputsByteArray)
    const after = await provider.getBalance(recipient);
    // check results
    expect(after.sub(before)).to.equal(privateTransactionAmount);
  });

  it("noir wasm should work", async () => {
    const privateTransactionAmount = utils.parseEther("1.0");
    
    let path = "../circuits/src/main.nr";
    // let path = "/Users/maximvezenov/Documents/dev/noir-projects/simple_shield/circuits/src/main.nr";
    const compiled_program = compile(path);
    const acir = compiled_program.acir;
    const abi = compiled_program.abi;

    console.log('abi: ' + abi);
  });
});


// Convert a hex string to a byte array
function hexToBytes(hex: string) {
  for (var bytes = [], c = 0; c < hex.length; c += 2)
      bytes.push(parseInt(hex.substr(c, 2), 16));
  return bytes;
}

function hexListToBytes(list: string[]) {
  let rawPubInputs = [];
  for (let i = 0; i < list.length; i++) {
    let rawPubInput = utils.arrayify(list[i]);
    rawPubInputs.push(rawPubInput)
  }
  // Get the total length of all arrays.
  let length = 0;
  rawPubInputs.forEach(item => {
    length += item.length;
  });

  // Create a new array with total length and merge all source arrays.
  let mergedRawPubInputs = new Uint8Array(length);
  let offset = 0;
  rawPubInputs.forEach(item => {
    mergedRawPubInputs.set(item, offset);
    offset += item.length;
  });
  return mergedRawPubInputs
}

async function callTurboVerifier(proof: number[], pub_inputs: number[]) {
  const verifierRes = await verifier.verify(proof, pub_inputs);
  console.log('verifier result ', verifierRes);
}

function nextLowestPowerOf2(n: number) {
  return Math.pow(2, Math.floor(Math.log(n) / Math.log(2)));
}


