import { ethers } from "hardhat";
const { provider } = ethers;
import { SignerWithAddress } from "@nomiclabs/hardhat-ethers/signers";
import { Contract, ContractFactory, utils } from "ethers";
import { expect } from "chai";
import { readFileSync } from 'fs';
import path from 'path';
// @ts-ignore
// import { plonk } from "snarkjs";
// @ts-ignore
// import { babyJub, pedersenHash, circomlib } from "circomlibjs";
// import { pedersenHash, MerkleTree } from "../utils/MerkleTree";
// @ts-ignore
// const { babyJub, pedersenHash } = require("circomlib");

const amount = process.env.ETH_AMOUNT || "1000000000000000000"; // 1 ether

// contract
let [Verifier, PrivateTransfer]: ContractFactory[] = [];
let [verifier, privateTransfer]: Contract[] = [];
let signers: SignerWithAddress[];
let commitments: string[] = [];
let root = ""

// TODO: Weird stuff with importing circomlib, will have to circle back, I might've setup TS wrong and need to import types
// currently not finding babyJub or pedersen
/** Compute pedersen hash */
// export function pedersen(data: any[]): string {
//   return babyJub.unpackPoint(pedersenHash.hash(data))[0].toString();
// }
// export function pedersenLeftRight(left: string, right: string): string {
//   // let combinedBuffer = Buffer.concat([left, right]);
//   return pedersen([left, right])
// }

before(async () => {
  PrivateTransfer = await ethers.getContractFactory("PrivateTransfer");
  Verifier = await ethers.getContractFactory("TurboVerifier");

  signers = await ethers.getSigners();


});

beforeEach(async function () {
  root = "0x1221a375f6b4305e493497805102054f2847790244f92d09f6e859c083be2627";
  let commitment = "0x2ab135000c911caaf6fcc25eeeace4ea8be41f3531b2596c0c1a7ac22eb11b57";
  commitments.push(commitment);
  verifier = await Verifier.deploy();
  privateTransfer = await PrivateTransfer.deploy(verifier.address, amount, root, commitments, { value: utils.parseEther("1.0") } );

  // TODO: get circomlibjs imported
  // let commit = pedersenHash(["0bff8247aa94b08d1c680d7a3e10831bd8c8cf2ea2c756b0d1d89acdcad877ad", "2a5d7253a6ed48462fedb2d350cc768d13956310f54e73a8a47914f34a34c5c4"]);
  // console.log(commit);
});
  
describe("mixer withdraw", () => {
  it("should work", async () => {
    const privateTransactionAmount = utils.parseEther("1.0");
    const abiCoder = new utils.AbiCoder;
    // const tree = new MerkleTree(3);
    // tree.insert(commitments[0]);
    // NOTE: this reads from the proof generated by nargo prove
    const proofBuffer = await readFileSync(path.resolve(__dirname,`../circuits/proofs/p.proof`));
    // let proofBuffer2 = proofBuffer.slice(4, -1);
    console.log('proof buffer', proofBuffer.toString());
    // let rawProof = abiCoder.encode([ "bytes" ], [ proofBuffer]);
    // console.log('raw proof: ', rawProof);
    let hexPubInputs = abiCoder.encode([ "uint256", "uint256[]"], [ 
      "0x1221a375f6b4305e493497805102054f2847790244f92d09f6e859c083be2627",
      [
      "0x0c9d3bdae689f66e3bc77823326726d140a48e989a1047ab25a9b6398b107118",
      "0x2f581370029b47a215f0379b936c089542d5d20767f1fa2dce0e59bbc4c4bd62"
    ] 
    ]);
    console.log('hex pub inputs', hexPubInputs);
    let rawPubInputs = utils.arrayify(hexPubInputs);
    console.log('raw pub inputs bytes', utils.arrayify(hexPubInputs));
    const public_inputs = rawPubInputs;
    let commitment = "0x2ab135000c911caaf6fcc25eeeace4ea8be41f3531b2596c0c1a7ac22eb11b57";
    let nullifierHash = "0x0c9d3bdae689f66e3bc77823326726d140a48e989a1047ab25a9b6398b107118";
    let root = "0x1221a375f6b4305e493497805102054f2847790244f92d09f6e859c083be2627";
    let recipient = "0x1c241d20d237f592061dc6a75ec01491e27f4816";
    let args = [proofBuffer, public_inputs, root, commitment, nullifierHash, recipient];
    // generate withdraw input (nullifier, commitment, etc)

    // generate proof NOTE: curently being done by nargo and fetched from circuits

    // perform withdraw
    const before = await provider.getBalance(recipient);
    let res = await privateTransfer.withdraw(...args);
    const after = await provider.getBalance(recipient);
    // check results
    expect(after.sub(before)).to.equal(privateTransactionAmount);
    expect(false).to.equal(true);
  });
});